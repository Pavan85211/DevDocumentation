Here's a Git document for the provided content:

---

# Input Output Redirection in Linux

## Types of Redirection

### 1. Overwrite Redirection:
Overwrite redirection is used when you want to store or save the output of a command to a file and replace all the existing content of that file.

- `>` standard output
- `<` standard input

**Implementation:**
To redirect standard output to a file, use the following command:

```bash
cat > file.txt
```

This command will take the input and write it to `file.txt`. It’s important to note that the `cat` command does not create a file but is used to copy input and display output on the screen.

To read the content of `file.txt` and print it to the terminal:

```bash
cat < file.txt
```

You can also use `cat` interactively by just typing `cat` and hitting enter. You will see the input printed back to the terminal.

```bash
cat
Hello this is GeeksForGeeks
Hello this is GeeksForGeeks
```

To append lines to an existing file, use append redirection.

```bash
cat >> file.txt
```

### 2. Append Redirection:
This type of redirection allows you to append the output to a file without overwriting the existing content.

- `>>` standard output
- `<<` standard input

**Implementation:**
A here-document is used to redirect input into an interactive shell script or program.

Syntax for a here-document:

```bash
command << delimiter
document
delimiter
```

Example:

```bash
cat << helo.txt
Hello This is 
GeeksForGeeks
helo.txt
```

Note: The delimiter marks the end of the document. It must be a single word without spaces or tabs.

### 3. Merge Redirection:
Merge redirection allows you to redirect the output of a command or program to a specific file descriptor instead of the standard output. 

- `p >& q` merges output from stream `p` with stream `q`.
- `p <& q` merges input from stream `p` with stream `q`.

**Error Redirection:**
Error redirection allows you to redirect error messages to a file rather than the screen.

By default, error streams are displayed on the screen. In error redirection, files generated include:

- standard input (0)
- standard output (1)
- standard error (2)

Example:

```bash
$ somerandomcommand 2>error.txt
```

This redirects errors to `error.txt`.

```bash
$ ls GEEK GFG > error.txt 2>&1
```

In this case, the error message generated by the missing directory is merged with the standard output and redirected to `error.txt`.

---

# Shell Scripting – Shell Variables

A shell variable stores values such as integers, filenames, strings, or shell commands in the shell.

### Rules for Variable Definition

- A variable name can contain alphabets (a-z, A-Z), digits (0-9), and underscores (_).
- A variable name must start with an alphabet or underscore.

**Valid Variable Names:**
```bash
ABC
_AV_3
AV232
```

**Invalid Variable Names:**
```bash
2_AN
!ABD
$ABC
&QAID
```

### Defining Variables:
Syntax:

```bash
variable_name = <variable data>
```

Example:

```bash
num="1"
name="Devil"
```

### Accessing Variable:
To access the variable data, append the variable name with `$`:

```bash
#!/bin/bash

VAR_1="Devil"
VAR_2="OWL"

echo "$VAR_1$VAR_2"
```

### Unsetting Variables:
To unset a variable:

```bash
#!/bin/bash

var1="Devil"
var2=23
echo $var1 $var2

unset var1

echo $var1 $var2
```

### Read-only Variables:
These variables cannot be modified once defined:

```bash
#!/bin/bash
var1="Devil"
var2=23
readonly var1
echo $var1 $var2
var1=23  # Error
echo $var1 $var2
```

### Variable Types:

1. **Local Variable:**
   These are variables specific to the current shell session and are not accessible by other shells.

   Example:
   ```bash
   name="Jayesh"
   ```

2. **Environment Variable:**
   These variables configure the shell environment and are available for all user processes.

   Example:
   ```bash
   export PATH=/usr/local/bin:$PATH
   ```

3. **Shell Variables:**
   These are variables set by the shell and contain useful information for shell functions.

   Examples:
   - `$PWD` = Stores current working directory
   - `$HOME` = Stores user’s home directory
   - `$SHELL` = Stores the path to the shell program

---

# Shell Scripting – Rules for Naming Variables

1. A variable name can contain letters, numbers, and underscores but cannot start with a number.
2. No whitespace should be placed around the assignment operator (`=`).
3. A variable name cannot contain special characters other than underscores.
4. Reserved words like `if`, `else`, `while`, etc., cannot be used as variable names.
5. Variable names cannot contain spaces.

---

# String Manipulation in Shell Scripting

To delete substrings:

- To remove the shortest substring match from the front of `$string`:

```bash
${string#substring}
```

- To remove the longest substring match from the front of `$string`:

```bash
${string##substring}
```

- To remove the shortest substring match from the back of `$string`:

```bash
${string%substring}
```

- To remove the longest substring match from the back of `$string`:

```bash
${string%%substring}
```

---

# Array Basics in Shell Scripting

Arrays store multiple values, and in shell scripting, all elements are treated as strings. Arrays are zero-indexed.

### Declaring Arrays

1. **Indirect Declaration:**

```bash
ARRAYNAME[INDEXNR]=value
```

2. **Explicit Declaration:**

```bash
declare -a ARRAYNAME
```

3. **Compound Assignment:**

```bash
ARRAYNAME=(value1 value2 value3)
```

--- 

 4. **Array Declaration**
To declare an array in Bash:

```bash
ARRAYNAME=(value1 value2 .... valueN)
```

Alternatively, you can assign values explicitly using index numbers:

```bash
ARRAYNAME=([1]=10 [2]=20 [3]=30)
```
 5. **Printing Array Values**

Below is a script `array_test.sh` that demonstrates multiple ways to print array values:

```bash
#!/bin/bash

# To declare a static Array
arr=("Jayesh" "Shivang" "1" "Vipul" "Nishant" "2")

# To print all elements of the array
echo "All elements of the array:"
echo "${arr[@]}"
echo "${arr[*]}"

# To print the first element
echo "The first element:"
echo "${arr[0]}"

# To print a selected index element
selected_index=3
echo "Selected index element at index $selected_index:"
echo "${arr[$selected_index]}"

# To print elements from a particular index
echo "Elements from a particular index:"
echo "${arr[@]:2}"
echo "${arr[*]:2}"

# To print elements in a range
echo "Elements in a range:"
echo "${arr[@]:1:3}"
echo "${arr[*]:1:3}"
```

---

### Conditional Statements in Shell Script

Bash supports several conditional statements. Below are some common ones:

#### 1. `if` Statement

```bash
if [ expression ]
then
    statement
fi
```

#### 2. `if-else` Statement

```bash
if [ expression ]
then
    statement1
else
    statement2
fi
```

#### 3. `if..elif..else..fi` (Else If Ladder)

```bash
if [ expression1 ]
then
    statement1
elif [ expression2 ]
then
    statement3
else
    statement4
fi
```

#### 4. Nested `if` Statement

```bash
if [ expression1 ]
then
    statement1
else
    if [ expression2 ]
    then
        statement2
    fi
fi
```

#### 5. `switch` Statement

Using `case` as a switch statement:

```bash
case $variable in
    "value1") statement1 ;;
    "value2") statement2 ;;
    *)
        default_statement ;;
esac
```

Example:

```bash
CARS="bmw"
case "$CARS" in
    "mercedes") echo "Affalterbach, Germany" ;;
    "audi") echo "Ingolstadt, Germany" ;;
    "bmw") echo "Chennai, India" ;;
esac
```

---

### Looping Statements in Shell Script

Loops are used for repeated execution of commands in a shell script.

#### 1. `while` Loop

```bash
while [ condition ]
do
    command1
    command2
done
```

Example:

```bash
#!/bin/bash
a=0
while [ $a -lt 10 ]
do
    echo $a
    a=$((a + 1))
done
```

#### 2. `for` Loop

```bash
for var in value1 value2 ... valueN
do
    command1
    command2
done
```

Example:

```bash
#!/bin/bash
COLORS="red green blue"
for COLOR in $COLORS
do
    echo "COLOR: $COLOR"
done
```

#### Loop Control: `break` and `continue`

- **`break`**: Exits the loop entirely.
- **`continue`**: Skips to the next iteration of the loop.

---

### Functions in Shell Script

Functions help break down complex scripts into smaller, reusable tasks.

#### Function Declaration

```bash
function_name(){
    # Function body
}
```

#### Example 1: Prime Number Function

```bash
is_prime(){
    if [ $1 -lt 2 ]; then
        return
    fi
    ctr=0
    for ((i=2; i<$1; i++))
    do
        if [ $(( $1 % i )) -eq 0 ]; then
            ctr=$(( ctr + 1 ))
        fi
    done
    if [ $ctr -eq 0 ]; then
        printf "%d " "$1"
    fi
}
```

#### Types of Functions

1. **Functions that return a value**:
    ```bash
    find_avg(){
        len=$#
        sum=0
        for x in "$@"
        do
            sum=$((sum + x))
        done
        avg=$((sum / len))
        return $avg
    }
    ```

2. **Functions that terminate the shell**:
    ```bash
    is_odd(){
        x=$1
        if [ $((x % 2)) == 0 ]; then
            echo "Invalid Input"
            exit 1
        else
            echo "Number is Odd"
        fi
    }
    ```

3. **Functions that alter the value of a variable**:
    ```bash
    increment(){
        a=$((a + 1))
        return
    }
    ```

4. **Functions that echo output**:
    ```bash
    hello_world(){
        echo "Hello World"
        return
    }
    ```

---

### Passing and Parsing Arguments in Shell Script

Bash scripts can accept parameters during execution.

#### 1. Passing Arguments to a Script

```bash
bash scriptname.sh arg1 arg2 arg3
```

#### 2. Accessing Arguments

To access arguments within the script:

```bash
echo "1st parameter = $1"
echo "2nd parameter = $2"
```

#### 3. Using Arguments in Variables

```bash
a=$1
b=$2
p=$((a * b))
echo "The product of $a and $b = $p"
```

#### 4. Checking for Null Parameters

```bash
if [[ -z $1 ]]; then
    echo "No parameter passed."
else
    echo "Parameter passed = $1"
fi
```

#### 5. Looping Through Arguments

```bash
for i in "$@"
do
    echo "$i"
done
```

#### 6. Counting Arguments

```bash
echo "The number of arguments passed are: $#"
```

---
